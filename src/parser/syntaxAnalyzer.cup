package parser;
import java_cup.runtime.*;
import java.io.FileReader;
import ctds_pcr.ast.*;
import java.util.*;
import ctds_pcr.ASTVisitor;
import ctds_pcr.semcheck.TypeCheckVisitor;
import ctds_pcr.semcheck.BreakContinueCheckVisitor;
import ctds_pcr.intermediateCode.TACVisitor;
import ctds_pcr.codeGeneration.*;
import ctds_pcr.optimization.*;



//{: symTable=new SymbolTable(); symTable.pushLevel(); symTable.addSymbolToLevel(ID); :}   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */

action code {:
//Global variables   
    private SymbolTable symTable= new SymbolTable(); //Symbol Table for check location(variables, methods) definition(not redefinition), invocation and referencing    
    //private boolean inMethodDecl;//Flag for drive Symbol Table level 
    //private int cantMain; //Amount of mehods with "Main" label for check that there is a only definition. 
    private int paramaterMain; //Amount of parameters that has a method with label "Main"
    private int methodOffset;

//     /*Method for set the offset to a method parameter list. The firsts 6 parameters int,string and boolean and the first 8 float will be in registers, 
// the followings will be in the stack*/
// //Este metodo le dice a cada metodo definido en el .ctds donde va a estar cada uno de sus parametros
//     private void setParametersOffset(List<Location> listParameters){
//       /*
//         //Remember that address has 64 bits.
//         STACK representation
        
//         -
//         Local Var= rbp+4*(amount of parameters+1)
//         Firsts 1..6 Arguments(are passed into register and then saved in stack)
//         last rbp= rbp(acces last ebp as rbp) 
//         dir retorno =rbp+8 
//         7 int,boolean, string arguments or 9 float arguments= rpb+16
//         .
//         .
//         .
//         +

//       */

//       //clone listparameters
//       LinkedList<Location> auxiliaryList=new LinkedList<Location>();
//       for(Location l: listParameters)
//         auxiliaryList.add(l);
      
//       int i=0;
//       int offset=-4;
//       int commonRegister=1;
//       int coprocessorRegister=1;
//       while (commonRegister<=6 && coprocessorRegister<=6 && auxiliaryList.size()>0){//while have parameters for assign offset, and have registers for any type make the offset assignation        
//         if (auxiliaryList.peek().getType()== Type.FLOAT){//consult about the type of the curren't elemen type 
//           auxiliaryList.pop().setOffset(offset);//will passed as parameters in coprocessor register
//           coprocessorRegister++;
//         }else{ 
//               auxiliaryList.pop().setOffset(offset);//will passed as parameters in common register
//               commonRegister++;
//              }
//          offset=offset-4;    
//          i++; 
//       }  
//       //case there are common register without assign
//       i=auxiliaryList.size();
//       List<Location> parametersWithOutOffset=new LinkedList<Location>();
//       while(commonRegister<=6 && i>0){//agoto registros comunes
//             if(auxiliaryList.peek().getType()!= Type.FLOAT){ 
//               auxiliaryList.pop().setOffset(offset); //will passed as parameters in common register
//               commonRegister++;
//               offset=offset-4;
//             }else
//                parametersWithOutOffset.add(auxiliaryList.pop()); //put in list the location without offset
//             i--;
//         }
//        //case there are coprocesor registers without assign
//         auxiliaryList.addAll(parametersWithOutOffset);
//         i=auxiliaryList.size();
//         parametersWithOutOffset=new LinkedList<Location>();
//         while(coprocessorRegister<=8 && i>0){//agoto registros del coprocesador
//               if(auxiliaryList.peek().getType()== Type.FLOAT){ 
//                 auxiliaryList.pop().setOffset(offset);//will passed as parameters in coprocessor register
//                 coprocessorRegister++;
//                 offset=offset-4;
//               }else
//                  parametersWithOutOffset.add(auxiliaryList.pop()); //put in list the location without offset
//             i--;
//           }
//       //case there aren't more registers for assign  
//       auxiliaryList.addAll(parametersWithOutOffset);
//       offset=16;//since there aren't more registers for parameters, put these in stack. 
//       while(auxiliaryList.size()>0){
//            auxiliaryList.pop().setOffset(offset);
//            offset= offset+4;
//       }          
//     }

//     private int countOffsetForSaveParam(List<Location> listParameters){
//       int cantParamsWillPassedInCommonRegister=0;
//       int cantParamsWillPassedInCoprocessorRegister=0;
//       for(Location l: listParameters)
//         if (l.getType()==Type.FLOAT) //if is passed into a register
//           cantParamsWillPassedInCoprocessorRegister++;
//         else
//           cantParamsWillPassedInCommonRegister++;

//      if (cantParamsWillPassedInCommonRegister>6) cantParamsWillPassedInCommonRegister=6;
//      if (cantParamsWillPassedInCoprocessorRegister>8) cantParamsWillPassedInCoprocessorRegister=8;

//       return cantParamsWillPassedInCommonRegister + cantParamsWillPassedInCoprocessorRegister;
//     }
:}

parser code{:    

    // //Method for report sintax error and information about this
    // public void report_error(String message, Object info) {
    //     StringBuilder m = new StringBuilder("Error");
    //     if (info instanceof java_cup.runtime.Symbol) {
    //         java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
    //         if (s.left >= 0) {                
    //             m.append(" in line "+(s.left+1));
    //             if (s.right >= 0)
    //                 m.append(", column "+(s.right+1));
    //         }
    //     }
    //     m.append(" : "+message);
    //     System.out.println(m + "  " + info.toString());
    //     System.exit(1); //Interrumpo la ejecucion
    // }
  
:};

init with {:  
             //We Can't use this block for parser variables inicialization, we should do this in a extra-rule called "begin"
          :};

  
   
// Terminales (tokens obtenidos por el analizador lexico).  

terminal  ELSE, IF, PARENIZQ, PARENDER,LLAB, LLCER, CORAB, CORCER, WHILE;

terminal Location ID;
terminal RESERV_INT;
terminal IntLiteral INT;
terminal SecStmt PUNTOCOMA;
terminal AssignOpType ASSIG;
terminal BinOpType  PLUS;
terminal ReturnStmt RETURN;


// No Terminales (producciones).  
                        
non terminal Type TYPE;
non terminal LinkedList<Statement> STATAMENT_STAR;
non terminal Statement STATAMENT;
non terminal Block ELSE_OPTIONAL;
non terminal AssignOpType ASSING_OP;
non terminal Expression EXPR;
non terminal Expression PROGRAM;
non terminal RefLocation LOCATION; 


precedence left  ELSE,IF;
precedence left  PUNTOCOMA;

precedence left  PLUS,RETURN,WHILE,ID;


// -------------Seccion de predencia y asociacion de los terminales----------- 


// ------------------- Seccion de la gramatica ------------------------ 
   
// La gramatica 

// TYPE ::=     {: symTable= new SymbolTable();
//                symTable.pushLevel(); //Push "global" level 
//               :} PROGRAM:p{:RESULT=p;:} ; //ver chequear

PROGRAM ::=             TYPE ID:ide LLAB STATAMENT_STAR:listField LLCER {: 
                                  RESULT= new Program(ide.getId(),listField, listMehod);
                                :};
TYPE ::=                 RESERV_INT:t {:RESULT=t;:};
			



STATAMENT_STAR  ::=     STATAMENT:s {:RESULT=new LinkedList<Statement>();:} 
                        | STATAMENT:s STATAMENT_STAR:listStatament {: listStatament.addFirst(s); RESULT=listStatament;:};





STATAMENT ::= 	        LOCATION:id ASSING_OP:op EXPR:expr PUNTOCOMA{:RESULT= new AssignStmt(id,op,expr,expr.getLineNumber(),expr.getColumnNumber());:}
                				| IF PARENIZQ EXPR:boolExpr PARENDER STATAMENT_STAR:b ELSE_OPTIONAL:else_optional{:RESULT= new IfStmt(boolExpr,b,else_optional,boolExpr.getLineNumber(),boolExpr.getColumnNumber());:}
              			    | WHILE EXPR:boolExpr STATAMENT_STAR:body{:RESULT= new WhileStmt(boolExpr,body,boolExpr.getLineNumber(),boolExpr.getColumnNumber());:}
              			    | RETURN:rt EXPR:expr PUNTOCOMA{:rt.setExpression(expr); RESULT=rt ;:} 
              			    | PUNTOCOMA:s{:RESULT=s;;:};


ELSE_OPTIONAL  ::=      ELSE STATAMENT_STAR:b{:RESULT= b;:}
			               		|{:RESULT= null;:} ;					



ASSING_OP  ::=         ASSIG:asign{: RESULT=asign;:};



LOCATION  ::=           ID:id
                            {:
                              Location l= symTable.getByIde(id.getId()); 
                              if (l==null){
                                report_error("Symbol not defined :",id);//If location could't be find in this level or upper level, it can't be refering     
                              }else{
                                if (l instanceof VarLocation)
                                  RESULT=new RefVarLocation(((VarLocation)l),id.getLineNumber(),id.getColumnNumber());
                                else report_error("Simbol isn't an Array Location  :",id);

                              }                                                      
                            :} 
                        | ID:id CORAB EXPR:expr CORCER
                          {:
                              Location l= symTable.getByIde(id.getId()); 
                              if (l==null){
                                report_error("Symbol not defined :",id);
                              }else{
                                if(l instanceof ArrayLocation){RESULT= new RefArrayLocation(((ArrayLocation)l),id.getLineNumber(),id.getColumnNumber(),expr);}
                                else{report_error("Simbol isn't an Array Location  :",id);};                               
                              }                          
                          :};


EXPR  ::= 		          LOCATION:l {:RESULT=l;:}
                				| INT:l{:RESULT= l;:}             			
                        | EXPR:lexpr PLUS:op EXPR:rexpr{:RESULT= new BinOpExpr(lexpr,op,rexpr,lexpr.getLineNumber(),lexpr.getColumnNumber());:} ;

